import base64, copy, datetime, MySQLdb as mysql, random, re, os, sys, threading, time, traceback, unicodedata, warnings, xml.dom.minidomfrom pydc_client import pydc_clientsql = {"hostname":"127.0.0.1","hostport":3306,"username":"SourceCode","password":"password","database":"verlihub","table_filelist":"sb_filelist","table_users":"users"}fa = {"client":None,"lock":threading.Semaphore(),"dir":"Sheriffbot/"}def u2a(s): return unicodedata.normalize('NFKD',s).encode('ascii','ignore') if type(s) is not str else stagmap = {"FileListing":"L","Directory":"D","File":"F"}attrmap = {"Name":"N","Size":"S","TTH":"T","Base":"B","Generator":"G","Version":"V","CID":"I","Created":"C","Updated":"U","Existence":"E"}"""Filelist Storage SystemAs the XML tags and attribute names are repeated many times, it is better if we translate them to single characters to reduce space consumption. For this translation, we use tagmap and attrmap.The created tag is set (to the current timestamp) every time a new item is detected, or if a previously deleted item is now back.The updated tag is set (to the current timestamp) every time the corresponding tag is found in the updated filelist, indicating that the item continues to exist.The existence tag is set when a particular tag is not updated in a cycle, indicating that the item represented by the tag is now missing. It contains the timestamps from the Created and Updated Attributes, which are deleted when this is created.In case the Size or the TTH attributes change, their old value is stored under the attribute S_* or T_* where * represents the time at which the change was detected. The new value is then stored in S or T.As Filenames are unique within a particular directory, they are used as a key to identify items. While it is possible that the other attributes may vary with time, this is assumed to be constant."""def filelist_update(base,original,update,now,uid,path):	global tagmap,attrmap,sql		# Initially remove all text nodes from original	for child in original.childNodes:		if child.nodeType is not xml.dom.Node.TEXT_NODE: continue # Ignore all except text nodes		original.removeChild(child) # Delete all text nodes		# Consider all nodes in update	if update is not None:		for child in update.childNodes:				if child.nodeType is xml.dom.Node.TEXT_NODE: continue # Ignore all text nodes			childattr = [(attrmap[i] if i in attrmap else i) for i in child.attributes.keys()] # Map all keys to single letters			childattr = dict(zip(childattr, map(lambda y: u2a(y.value),child.attributes.values()) )) # Get updated node's attributes as a dictionary			if "N" not in childattr: childattr["N"] = u""						# Check if this node exists in the original, as identified by the name			current = None 			for child2 in original.childNodes:				if child2.nodeType is xml.dom.Node.TEXT_NODE: continue				if child2.nodeName!=tagmap[child.nodeName]: continue				if not child2.hasAttribute("N"): continue				if child2.getAttribute("N")!=childattr["N"]: continue				current = child2				break							# Create a new node if required, and set it creation/updation timestamps			created = False			if current is None:				current = base.createElement(tagmap[child.nodeName])				created = True				if current.nodeName=="L": current.setAttribute("N","")			if not current.hasAttribute("C"): current.setAttribute("C",now)			current.setAttribute("U",now)						# Memory Problem Source			# Add attributes where required. In case of updates, store previous values with timestamp of change as part of key			for attr in childattr:				value = u2a(childattr[attr])				if not current.hasAttribute(attr): current.setAttribute(attr,value);				elif current.getAttribute(attr)!=value:					current.setAttribute(attr+"_"+now,current.getAttribute(attr))					current.setAttribute(attr,value)								# Add the element to the heirarchy and recurse if needed, added data to MySQL table.			if created: original.appendChild(current)			name = u2a(current.getAttribute("N"))			if current.nodeName in ["L","D"]:				# sql["cursor"].execute("INSERT INTO "+sql["table_filelist"]+" VALUES (%d,'%s',null,null);" % (uid, re.escape(path+name+os.sep)) )				filelist_update(base,current,child,now,uid,path+name+os.sep)			else:				# sql["cursor"].execute("INSERT INTO "+sql["table_filelist"]+" VALUES (%d,'%s',%d,'%s');" % (uid, re.escape(path+name), int(u2a(current.getAttribute("S"))), u2a(current.getAttribute("T"))) )				pass				# In case it is detected that a particular node wasent updated, it means it was deleted. Save that information too.	for child in original.childNodes:		if not child.hasAttribute("U"): continue		if u2a(child.getAttribute("U"))==now: continue		child.setAttribute("E_"+child.getAttribute("C"),child.getAttribute("U"))		child.removeAttribute("C")		child.removeAttribute("U")				# If reqd, recurse through all subdirectories, to update all existance tags		if child.nodeName in ["L","D"]:			filelist_update(base,child,None,now,uid,path)			def filelist_analyze(filename,nick):	global fa, sql		try:				print time.strftime("%d-%b-%Y %H:%M:%S",time.localtime())+" "+"SheriffBot : "+nick+" Filelist Download Complete."				# Insert TimeStamp into Filename & Rename It		now = datetime.datetime.now()		now = now.strftime("%Y%m%d%H%M%S")		oldfilename = filename[:-4] # ignore the trailing .bz2		filename = filename.split(os.sep)		filename[-1] = filename[-1].split(".")		filename[-1][0] = filename[-1][0][1:] # Remove the starting @		filename[-1] = ".".join(filename[-1][:-2])+" # "+now+"."+filename[-1][-2]		filename = os.sep.join(filename)		os.rename(oldfilename,filename)				# raise Exception("Bypassing XML Update.")				sql["cursor"].execute("SELECT uid FROM "+sql["table_users"]+" WHERE nickname=%s AND deleted=0;",(nick,))		if sql["cursor"].rowcount==0:			print time.strftime("%d-%b-%Y %H:%M:%S",time.localtime())+" "+"SheriffBot : "+nick+" Filelist XML Update Failed."			raise Exception("XML Update Error : Unknown User.")		else:			uid = int(sql["cursor"].fetchone()["uid"])				# Update the main filelist of the user.		filelist_main = fa["dir"]+str(uid)+" # "+nick+".xml"		if os.path.isfile(filelist_main+".bz2"):			fa["client"].bz2_compress(filelist_main+".bz2",False)			filelist_old = xml.dom.minidom.parse(filelist_main)		else: filelist_old = xml.dom.minidom.Document()		filelist_new = xml.dom.minidom.parse(filename)		# sql["cursor"].execute("DELETE FROM "+sql["table_filelist"]+" WHERE uid=%d;" % (uid,) )		filelist_update(filelist_old,filelist_old,filelist_new,now,uid,"")		sql["link"].commit();		print >>open(filelist_main,"w"), filelist_old.toprettyxml()		fa["client"].bz2_compress(filelist_main,True)		os.remove(filelist_main)		print time.strftime("%d-%b-%Y %H:%M:%S",time.localtime())+" "+"SheriffBot : "+nick+" Filelist XML Update Complete."				# Discard the current filelist		os.remove(filename)			except Exception as e:		if False:			print			print "Exception in Callback Function for", nick, ":", e			exc_type, exc_value, exc_traceback = sys.exc_info()			traceback.print_exception(exc_type, exc_value, exc_traceback, limit=10, file=sys.stdout)			print	fa["lock"].release()if __name__=="__main__":	try:		sql["link"] = mysql.connect(host=sql["hostname"],port=sql["hostport"],user=sql["username"],passwd=sql["password"],db=sql["database"]);		sql["cursor"] = sql["link"].cursor(mysql.cursors.DictCursor)		warnings.filterwarnings('ignore', category = mysql.Warning) # CREATE IF NOT EXISTS generates an unnecesary warning		# sql["cursor"].execute("CREATE TABLE IF NOT EXISTS "+sql["table_filelist"]+" (uid int, name tinytext, size bigint, tth tinytext)")		warnings.resetwarnings()			except Exception as e:		exc_type, exc_value, exc_traceback = sys.exc_info()		traceback.print_exception(exc_type, exc_value, exc_traceback, limit=10, file=sys.stdout)		sys.exit(1)	data = { "mode":True, "name":"pyDC", "host":"127.0.0.1","nick":"SourceCode","pass":"password","desc":"","email":"","sharesize":1073741824,"localhost":"127.0.0.1","overwrite":True}	def debug(debug_mode): return None if debug_mode==0 else open("debug.txt","w").write if debug_mode==1 else sys.stdout.write if debug_mode==2 else None	fa["client"] = pydc_client().configure(data).link({"mainchat":sys.stdout.write,"debug":debug(1) }).connect("0/1/0");	if not os.path.isdir(fa["dir"]): os.mkdir(fa["dir"]) # Ensure that the directory in which modified filelists will be saved exists.	time.sleep(3); # Wait for the connection to established and session to be verified.			interval = 5 # seconds	while True:		fa["client"]._nicklock.acquire()		nicklist = copy.deepcopy(fa["client"]._nicklist)		# nicklist = {'SourceCode':{'bot':False}}		fa["client"]._nicklock.release()		start = int(time.time())		for nick in nicklist:			if nick==data["nick"] or nick not in fa["client"]._nicklist or nicklist[nick]["bot"]: continue			filelist = fa["dir"]+nick+".xml"			if os.path.isfile(filelist):				x = int(time.time())-int(os.path.getmtime(filelist))				if x<interval: continue			fa["lock"].acquire()			def release(nick):				print time.strftime("%d-%b-%Y %H:%M:%S",time.localtime())+" "+"SheriffBot : "+nick+" Filelist Download Failed."				fa["lock"].release()			print time.strftime("%d-%b-%Y %H:%M:%S",time.localtime())+" "+"SheriffBot : "+nick+" Filelist Download Started."			fa["client"].download_filelist(nick,filelist_analyze,nick,release,nick)		end = int(time.time())		x = interval-end+start		if x>0:				print time.strftime("%d-%b-%Y %H:%M:%S",time.localtime())+" "+"SheriffBot : "+"Sleeping for",x,"seconds."			time.sleep(x) # Wait for a fixed period before proceeding to redownload filelists of the same users